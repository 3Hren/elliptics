# log file
# set to 'syslog' without inverted commas if you want elliptics to log through syslog
log = /dev/stderr

# log mask
#log_mask = 10
log_mask = 15

# specifies whether to join storage network
join = 1

# config flags
# bits start from 0, 0 is unused (its actuall above join flag)
# bit 1 - do not request remote route table
# bit 2 - mix states before read operations according to state's weights
# bit 3 - do not checksum data on upload and check it during data read
# bit 4 - do not update metadata at all
# bit 5 - randomize states for read requests
flags = 4

# node will join nodes in this group
group = 2

# list of remote nodes to connect
# address:port:family where family is either 2 (AF_INET) or 10 (AF_INET6)
# address can be host name or IP
#remote = 1.2.3.4:1025:2 2.3.4.5:2345:2

# local address to bind to
# port 0 means random port
addr = localhost:1025:2

# wait timeout specifies number of seconds to wait for command completion
wait_timeout = 60

# this timeout specifies number of seconds to wait before killing
# unacked transaction
check_timeout = 60

# number of IO threads in processing pool
io_thread_num = 50

# number of IO threads in processing pool dedicated to nonblocking operations
# they are invoked from recursive commands like DNET_CMD_EXEC, when script
# tries to read/write some data using the same id/key as in original exec command
nonblocking_io_thread_num = 2

# number of thread in network processing pool
net_thread_num = 16

# specifies history environment directory
# it will host file with generated IDs
# and server-side execution scripts
history = /tmp/history

# specifies whether to go into background
daemon = 0

# authentification cookie
# if this string (32 bytes long max) does not match to server nodes,
# new node can not join and serve IO
auth_cookie = qwerty

# Background jobs (replica checks and recovery) IO priorities
# ionice for background operations (disk scheduler should support it)
# class - number from 0 to 3
# 0 - default class
# 1 - realtime class
# 2 - best-effort class
# 3 - idle class
bg_ionice_class = 3
# prio - number from 0 to 7, sets priority inside class
bg_ionice_prio = 0

# IP priorities
# man 7 socket for IP_PRIORITY
# server_net_prio is set for all joined (server) connections
# client_net_prio is set for other connection
# is only turned on when non zero
server_net_prio = 1
client_net_prio = 6

# Size of operation lock hash table
# These locks guard command execution, they are grabbed for allmost all operations
# except recursive (for example when DNET_CMD_EXEC reads or writes data) and some
# maintenance commands like statistics gathering and route table update
# Recovery process also runs without locks grabbed, since this locks operation quite
# for a long period of time, which may interfere with clients IO
oplock_num = 10240

# anything below this line will be processed
# by backend's parser and will not be able to
# change global configuration

# backend can be 'filesystem' or 'blob'

backend = filesystem

# Number of bits (from the beginning of the object ID) used
# for directory, which hosts given object
directory_bit_number = 8

# Root directory for data objects
root = /tmp/root

# zero here means 'sync on every write'
# positive number means file writes are never synced
# and metadata is synced every @sync seconds
sync = 0



#backend = blob

# zero here means 'sync on every write'
# positive number means data amd metadata updates
# are synced every @sync seconds
#sync = 0

# eblob objects prefix. System will append .NNN and .NNN.index to new blobs
#data = /tmp/blob/data

# Align all writes to this boundary
#data_block_size = 1024

# blob processing flags (bits start from 0)
# bit 0 - if set, eblob reserves 10% of total space or size of the blob (which is bigger)
# 		By default it is turned off and eblob only reserves size of the blob
# 		This is useful (needed) to be able to run defragmentation
# bit 2 - turn on overwrite mode - data can be overwritten in place instead
# 		of appending it at the end. This mode is turned on for metadata
# 		writes (column 1), this bit enables it for all other writes too
#blob_flags = 1

# Number of threads used to populate data into RAM at startup
#iterate_thread_num = 1

# Maximum blob size. New file will be opened after current one
# grows beyond @blob_size limit
# Supports K, M and G modifiers
#blob_size = 10G

# Maximum number of records in blob.
# When number of records reaches this level,
# blob is closed and sorted index is generated.
# Its meaning is similar to above @blob_size,
# except that it operates on records and not bytes.
records_in_blob = 10000000

# Timeout for defragmentation process to start
# In every time slot eblob will only defragment one blob,
# since system reserves enough space for only one blob
# After next timeout old (already defragmented into copy)
# blob will be closed (this will actually free space) and
# next one will be defragmented.
#
# Defragmentation operation is rather costly (even if nothing
# is going to be copied, defragmentation still checks every index
# to determine number of removed keys)
# It is recommended to set it to hours (it is in seconds) or more
# Default: -1 or none
defrag_timeout = 3600

# Percentage of removed entries (compared to number of all keys in blob)
# needed to start defragmentation. If number of removed keys is less than
# (removed + not removed) * $defrag_percentage / 100 then defragmentation
# process will skip given blob
defrag_percentage = 25
