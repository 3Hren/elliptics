## FastCGI programs have the same functionality as CGI programs,
## but are considerably faster through lower interpreter startup
## time and socketed communication
##
## Documentation: /usr/share/doc/lighttpd-doc/fastcgi.txt.gz
##                http://www.lighttpd.net/documentation/fastcgi.html

server.modules   += ( "mod_fastcgi" )

#fastcgi.debug = 1

## Start an FastCGI server for php (needs the php5-cgi package)
fastcgi.server    = ( ".mp3" => 
	((
		"bin-path" => "/tmp/dnet/bin/dnet_fcgi",
		"host" => "127.0.0.1",
		"port" => 1025,
		"max-procs" => 1,
		"idle-timeout" => 20,
		"check-local" => "disable",
		"bin-environment" => ( 
			# this parameter is used to specify object name, which will be transformed into elliptics ID
			"DNET_FCGI_ID_PATTERN" => "name=",

			# server groups used for data storage
			# each group basically means a separate copy in given set of nodes
			"DNET_FCGI_GROUPS" => "1:2:3",

			# above list of groups will be randomized starting from this index,
			# e.g. groups 1:2:3:4:5 and DNET_FCGI_RANDOMIZE_GROUPS_FROM=2 will be
			# changed, for example, to 1:2:4:3:5 or 1:2:5:3:4, i.e. first 2 groups
			# will be unchanged.
			#
			# When system will select group to read data from, it will try groups
			# from this randomized array one by one.
			"DNET_FCGI_RANDOMIZE_GROUPS_FROM" => "2",

			# parameter delimiter
			"DNET_FCGI_ID_DELIMITER" => "&",

			# fastcgi daemon log
			# if set to "syslog" FCGI will write through syslog
			"DNET_FCGI_LOG" => "/tmp/fcgi.log",

			# log mask:
			# define DNET_LOG_NOTICE		(1<<0)
			# define DNET_LOG_INFO			(1<<1)
			# define DNET_LOG_TRANS			(1<<2)
			# define DNET_LOG_ERROR			(1<<3)
			# define DNET_LOG_DSA			(1<<4)
			"DNET_FCGI_NODE_LOG_MASK" => "0xf",

			# check for stall transactions in seconds
			"DNET_FCGI_NODE_CHECK_TIMEOUT" => "30",

			# this string is added as the first dir after document root
			# (i.e. just after hostame) in lookup replies
			"DNET_FCGI_ROOT_PATTERN" => "",

			# Default success return status
			"DNET_FCGI_SUCCESS_STATUS_PATTERN" => "Status: 301"

			# local node address, can be 0.0.0.0:0:2
			# the last number is network address family, namely 2 is IPv4
			"DNET_FCGI_NODE_LOCAL_ADDR" => "devfs1.yandex.net:1026:2",

			# list of nodes to connect through
			"DNET_FCGI_REMOTE_ADDR" => "devfs1:1030:2",

			# maximum POST request size in bytes
			"DNET_FCGI_MAX_REQUEST_SIZE" => "10485760",

			# This port is used to generate redirect URL
			# basically it will have following format:
			# $address/$root/$port_diff/$id_dir/$id
			#
			# $address is remote host address (IP or domain name depending on $DNET_FCGI_DNS_LOOKUP key
			# $root is above $DNET_FCGI_ROOT_PATTERN
			# $port_diff is difference between remote elliptics node port and this $DNET_FCGI_BASE_PORT
			#   so for node running at 1025 port we will have $address/$root/1/$id... URL in this example
			# Used to simplify putting multiple elliptics node storage directories into the same document root
			"DNET_FCGI_BASE_PORT" => "1024",

			# Number of low ID bits used to generate subdir in file IO backend on the storage nodes.
			# Used when generating direct URI to the file on the storage node.
			# Must be in sync with all storage nodes.
			"DNET_FCGI_STORAGE_BITS" => "12",

			# whether POST is allowed for this fastcgi daemon
			"DNET_FCGI_POST_ALLOWED" => "1",

			# secret key used to generate cookies and secret
			"DNET_FCGI_SIGN_KEY" => "some secure sign key",

			# secret/cookie generation hash
			"DNET_FCGI_SIGN_HASH" => "sha256",

			# random file to get entropy from
			"DNET_FCGI_RANDOM_FILE" => "/dev/urandom",

			# header to check for the cookie data
			# pretty much obvious
			"DNET_FCGI_COOKIE_HEADER" => "Cookie",

			# this secret key is used to generate cookie
			# It will hash of concatenated key, 4 concatenated random bytes and timestamp.
			# More details in README.
			"DNET_FCGI_COOKIE_KEY" => "some secret key to generate cookie",

			# Cookie part added after expiration
			"DNET_FCGI_COOKIE_ADDON" => "; path=/; domain=.some.subdomain."

			# cookie key for this daemon
			"DNET_FCGI_COOKIE_DELIMITER" => "Our_company_cookie=";

			# you won't believe, but this is placed as end of the cookie
			"DNET_FCGI_COOKIE_ENDING" => ";",

			# cookie expiration interval in seconds
			"DNET_FCGI_COOKIE_EXPIRATION_INTERVAL" => "1209600",

			# if present in URI, object will be downloaded and returned by fcgi proxy
			"DNET_FCGI_DIRECT_PATTERN_URI" => "direct=1",

			# one of them must be present in ID to be downloaded by fcgi proxy
			# * - is allow-all wildcard
			"DNET_FCGI_DIRECT_PATTERNS" => ".xml .jpg *",

			# fcgi proxy will set appropriate content type when requested ID ends
			# on the one of the following patterns
			"DNET_FCGI_CONTENT_TYPES" => "xml,text/xml jpg,image/jpeg txt,text/plain",

			# set if we want to return DNS name instead of IP address
			"DNET_FCGI_DNS_LOOKUP" => "1",

			# remove object if present in URI
			"DNET_FCGI_UNLINK_PATTERN_URI" => "unlink=1",

			# request remote nodes statistics
			# plain stat will request stats and return 200 status if either
			# number of received replies is more than $DNET_FCGI_STAT_BAD_LIMIT (if set)
			# or is more than number of bad replies
			"DNET_FCGI_STAT_PATTERN_URI" => "/stat",

			# this will always return 200 status with XML data showing node statistics:
			# CPU and memory usage and filesystem data (total and available sizes, FSID and number of files)
			# if such statistics is supported
			"DNET_FCGI_STAT_LOG_PATTERN_URI" => "/stat_log",
			
			# plain stat request will return 400 status when number of bad replies returned from the
			# storage is more than this number or when number of good replies is less than that.
			# It is not used when log statistics is requested.
			"DNET_FCGI_STAT_BAD_LIMIT" => "1",

			# external library, which has to export 4 functions:
			# dnet_fcgi_external_init(const char *data) - used to initialize external engine,
			# 	its $data is obtained from $DNET_FCGI_EXTERNAL_DATA variable and can be NULL
			# dnet_fcgi_external_exit(void) - cleanups external engine
			# int dnet_fcgi_external_callback_start(const char *query, const char *addr,
			# 	const char *id, const int length)
			# int dnet_fcgi_external_callback_stop(const char *query, const char *addr,
			# 	const char *id, const int length)
			# these callbacks can process query and address and return status code.
			#
			"DNET_FCGI_EXTERNAL_LIB" => "/tmp/geobase/libdnet_geobase.so.0.0.0",
			"DNET_FCGI_EXTERNAL_DATA" => "/var/cache/geobase/geodata.txt",

			# permanent headers separated by | character
			# added before any other header no matter which status is returned or object requested
			"DNET_FCGI_PERMANENT_HEADERS" => "Connection: close|X-header: qweqweqwe|asdasdasd: zxczxczxc",

			# if number of upload errors is more than this variable, then upload will return 403 status
			# By default it does not tolerate errors, i.e. if there is at least one error, then upload will fail.
			#
			# Please note, that system uploads two times more transactions than number of groups,
			# since we upload data and history update, so this counter should be set appropriately, i.e.
			# for each copy it likely should be increased by 2.
			"DNET_FCGI_TOLERATE_UPLOAD_ERROR_COUNT" => "0",

			# version pattern used to select appropriate transaction from the history log
			"DNET_FCGI_VERSION_PATTERN" => "version=",

			# make it non-zero if you want to add 'Last Modified' header for get requests
			"DNET_FCGI_LAST_MODIFIED" => "1",

			# Number of nodes proxy has to be connected to to allow data upload.
			# If number of connected nodes is less than this number, POST will fail.
			"DNET_FCGI_UPLOAD_HOST_LIMIT" => "3",

			# timestamp pattern which specifies time (in seconds since Epoch) given transaction must have
			# in transaction log. History file associated with data transaction itself will contain current
			# time, only history entries for main object is updated. Thus direct transactions (when we do
			# not hash content, only name) will not have it.
			"DNET_FCGI_TIMESTAMP_PATTERN" => "timestamp=",

			# if this URI parameter is presented in GET request,
			# stored data will be treated as combined object,
			# containing timestamp and optionally other fields
			#
			# In POST request it means all parameters will be stored with data
			"DNET_FCGI_EMBED_PATTERN" => "embed_timestamp",

			# temporary dir
			"DNET_FCGI_TMP_DIR" => "/dev/shm",

			# If set we will add <region> tag into <download-info> XML output.
			"DNET_FCGI_PUT_REGION" => "1",

			# if present in query data will be appended to the end of the object
			"DNET_FCGI_APPEND_PATTERN" => "append"

			# use remote node's LA numbers to select storage to get data from
			"DNET_FCGI_USE_LA" => "1",

			# this header name is used to get remote address from
			# it should be written in FCGI format, i.e. for client-generated
			# it will be something like HTTP_X_REAL_IP or REMOTE_ADDR for server-generated.
			# If no address was found REMOTE_ADDR header will be checked.
			"DNET_FCGI_ADDR_HEADER" => "REMOTE_ADDR",

			# groups pattern is used by client to specify whcih groups should be used
			# for data IO. It can be colon-separated string like
			# groups=1:2:3
			# or
			# groups=auto4
			# the latter means that fcgi module will automatically select 4 groups
			# from the pool it is connected to, or will use 0, 1, 2, 3.
			# If number of groups fcgi is connected to is less than requested number,
			# the rest of the groups will be equal to the biggest selected plus increasing
			# number, i.e. if we connected to groups 1 and 3 and we request 4 groups,
			# then fcgi will use groups 1, 3, 4 and 5
			"DNET_FCGI_GROUPS_PATTERN" => "groups=",

			# Multiple read pattern.
			# If more than zero, then system will read multiple transaction histories
			# (sorted originally by LA, number of copies to read equals to specified in
			# URI number), then they will be sorted by latest transaction timestamp.
			# If multiple read succeeded successfully, ids it returns will be sorted
			# by latest write timestamp, which in turn means that the first group specified
			# contains latest data.
			"DNET_FCGI_MULTIPLE_PATTERN" => "multiple=",
		)
	))
)
